PS:Construct an expression tree from the given prefix expression    eg. +--a*bc/def and traverse it using post order traversal (non recursive) and then delete the entire tree.

#include<iostream>
#include<stack>
#include<string>

using namespace std;

// Structure of the node of the expression tree
struct Node {
    char data;       // Stores the character data of the node (operand or operator)
    Node* left;    // Pointer to the left child
    Node* right;   // Pointer to the right child
};

// Function to create a new node of the expression tree
Node* newNode(char data) {
    Node* node = new Node;  // Dynamically allocate memory for a new Node
    node->data = data;      // Assign the given data to the node's data field
    node->left = NULL;     // Initialize the left child pointer to NULL
    node->right = NULL;    // Initialize the right child pointer to NULL
    return node;            // Return the pointer to the newly created node
}

// Function to construct an expression tree from the given prefix expression
Node* constructExpressionTree(string prefix) {
    stack<Node*> s;         // Create a stack of Node pointers to store nodes during construction
    int len = prefix.length(); // Get the length of the prefix expression string
    for (int i = len - 1; i >= 0; i--) { // Iterate through the prefix expression from right to left
        char ch = prefix[i];  // Get the character at the current position
        if (isdigit(ch) || isalpha(ch)) { // Check if the character is an operand (digit or alphabet)
            s.push(newNode(ch));     // If it's an operand, create a new node and push it onto the stack
        } else { // If the character is an operator
            Node* node = newNode(ch); // Create a new node for the operator
            node->left = s.top();    // Pop the top node from the stack and make it the left child
            s.pop();                // Remove the left child from the stack
            node->right = s.top();   // Pop the next node from the stack and make it the right child
            s.pop();                // Remove the right child from the stack
            s.push(node);           // Push the operator node onto the stack
        }
    }
    return s.top(); // After processing the entire prefix expression, the root of the tree is the only node left in the stack
}

// Function to traverse the expression tree in postorder without recursion
void postorderTraversal(Node* root) {
    if (root == NULL) return; // If the tree is empty, return
    stack<Node*> s;         // Create a stack to store nodes during traversal
    s.push(root);            // Push the root node onto the stack
    Node* prev = NULL;      // Initialize a pointer to the previously visited node to NULL
    while (!s.empty()) {      // Continue as long as the stack is not empty
        Node* curr = s.top(); // Get the current node at the top of the stack
        // If it is the first node, or we are coming from the left or right child of the current node
        if (prev == NULL || prev->left == curr || prev->right == curr) {
            if (curr->left) {     // If the current node has a left child
                s.push(curr->left); // Push the left child onto the stack
            } else if (curr->right) { // If the current node has a right child
                s.push(curr->right);  // Push the right child onto the stack
            }
        }
        // If we are coming from the left child
        else if (curr->left == prev) {
            if (curr->right) {     // If the current node has a right child
                s.push(curr->right);  // Push the right child onto the stack
            }
        }
        // If we are coming from the right child
        else {
            cout << curr->data << " "; // Print the data of the current node (postorder)
            s.pop();              // Pop the current node from the stack
        }
        prev = curr; // Update the previous node to the current node
    }
    cout << endl;    // Print a newline character after the traversal
}

// Function to delete the expression tree
void deleteTree(Node* root) {
    if (root == NULL) return; // If the tree is empty, return
    stack<Node*> s;         // Create a stack to store nodes during deletion
    s.push(root);            // Push the root node onto the stack
    Node* prev = NULL;      // Initialize a pointer to the previously visited node to NULL
    while (!s.empty()) {      // Continue as long as the stack is not empty
        Node* curr = s.top(); // Get the current node at the top of the stack
        // If it is the first node, or we are coming from the left or right child of the current node
        if (prev == NULL || prev->left == curr || prev->right == curr) {
            if (curr->left) {     // If the current node has a left child
                s.push(curr->left); // Push the left child onto the stack
            } else if (curr->right) { // If the current node has a right child
                s.push(curr->right);  // Push the right child onto the stack
            }
        } else if (curr->left == prev) { // If we are coming from the left child
            if (curr->right) {
                s.push(curr->right);
            }
        } else {
            delete curr;      // Delete the current node
            s.pop();          // Pop the current node from the stack
        }
        prev = curr;          // Update the previous node
    }
    cout << "Tree Deleted."; // Print a message indicating that the tree has been deleted
}

int main() {
    string prefix = "+--a*bc/def"; // Define the prefix expression string
    Node* root = constructExpressionTree(prefix); // Construct the expression tree from the prefix expression
    cout << "Postorder Traversal: ";
    postorderTraversal(root);       // Traverse the tree in postorder and print the result
    deleteTree(root);               // Delete the expression tree to free memory
    return 0;                       // Return 0 to indicate successful program execution
}

