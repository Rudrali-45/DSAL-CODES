PS:Given sequence k = k1 <k2 < ... <kn of n sorted keys, with a search probability pi for each key ki . 
Build the Binary search tree that has the least search cost given the access probability for each key? 


#include<iostream>
using namespace std;

// Function declaration for constructing the optimal BST
void con_obst(void);
// Function declaration for printing the structure of the optimal BST
void print(int,int);

// Global arrays to store probabilities, weights, costs, and roots for OBST
float a[20],b[20],wt[20][20],c[20][20];
int r[20][20],n; // 'n' stores the number of keys

// Main function - entry point of the program
int main()
{
	int i;
	cout<<"\n**** PROGRAM FOR OBST ******\n"; // Prints program title
	cout<<"\nEnter the no. of nodes : "; // Prompts user to enter the number of keys
	cin>>n; // Reads the number of keys

	cout<<"\nEnter the probability for successful search :: ";
	cout<<"\n----------------\n";
	for(i=1;i<=n;i++) // Loop to read probabilities for successful searches (p1, p2, ..., pn)
	{
		cout<<"p["<<i<<"]";
		cin>>a[i]; // Reads probability pi and stores in a[i]
	}

	cout<<"\nEnter the probability for unsuccessful search :: ";
	cout<<"\n------------------\n";
	for(i=0;i<=n;i++) // Loop to read probabilities for unsuccessful searches (q0, q1, ..., qn)
	{
		cout<<"q["<<i<<"]";
		cin>>b[i]; // Reads probability qi and stores in b[i]
	}

	con_obst(); // Calls the function to construct the optimal BST
	print(0,n); // Calls the function to print the structure of the optimal BST
	cout<<endl;
	return 0; // Returns 0 to indicate successful execution
}

// Function to construct the optimal BST
void con_obst(void)
{
	int i,j,k,l,min;
	for(i=0;i<n;i++)
	{ 	//Initialisation
		c[i][i]=0.0; // Cost of empty subtree
		r[i][i]=0; // Root of empty subtree
		wt[i][i]=b[i]; // Weight of subtree with dummy node qi
		// for j-i=1 can be j=i+1
		wt[i][i+1]=b[i]+b[i+1]+a[i+1]; // Weight of subtree containing  ki+1
		c[i][i+1]=b[i]+b[i+1]+a[i+1]; // Cost of subtree containing ki+1
		r[i][i+1]=i+1; // Root of subtree containing ki+1 is ki+1
	}
	c[n][n]=0.0; // Cost of empty subtree
	r[n][n]=0; // Root of empty subtree
	wt[n][n]=b[n]; // Weight of subtree with dummy node qn
	//for j-i=2,3,4....,n
	for(i=2;i<=n;i++) // Loop to iterate over subtree lengths
	{
		for(j=0;j<=n-i;j++) // Loop to iterate over starting indices of subtrees
		{
			wt[j][j+i]=b[j+i]+a[j+i]+wt[j][j+i-1]; // Calculate weight of the subtree
			c[j][j+i]=9999; // Initialize cost to a large value
			for(l=j+1;l<=j+i;l++) // Loop to find the best root for the subtree
			{
				if(c[j][j+i]>(c[j][l-1]+c[l][j+i])) // Check if choosing 'l' as root improves the cost
				{
					c[j][j+i]=c[j][l-1]+c[l][j+i]; // Update cost if a better root is found
					r[j][j+i]=l; // Store the best root for the subtree
				}
			}
			c[j][j+i]+=wt[j][j+i]; // Add the weight of the subtree to its cost
		}
		cout<<endl;
	}
	cout<<"\n\nOptimal BST is :: ";
	cout<<"\nw[0]["<<n<<"] :: "<<wt[0][n]; // Prints the weight of the optimal BST
	cout<<"\nc[0]["<<n<<"] :: "<<c[0][n]; // Prints the cost of the optimal BST
	cout<<"\nr[0]["<<n<<"] :: "<<r[0][n]; // Prints the root of the optimal BST
}

// Function to print the structure of the optimal BST (recursive)
void print(int l1,int r1)
{
	if(l1>=r1) // Base case: if left index is greater or equal to right index, return
		return;
	if(r[l1][r[l1][r1]-1]!=0)
		cout<<"\n Left child of "<<r[l1][r1]<<" :: "<<r[l1][r1][r1]-1; // Print left child
	if(r[r[l1][r1]][r1]!=0)
		cout<<"\n Right child of "<<r[l1][r1]<<" :: "<<r[r[l1][r1]][r1]; // Print right child
	print(l1,r[l1][r1]-1); // Recursively print the left subtree
	print(r[l1][r1],r1); // Recursively print the right subtree
	return;
}
