PS:You have a business with several offices; you want to lease phone lines to connect them up with each other; 
and the phone company charges different amounts of money to connect different pairs of cities. 
You want a set of lines that connects all your offices with a minimum total cost. 
Solve the problem by suggesting appropriate data structures.

#include<iostream>
using namespace std;

// Class to represent the graph and find the minimum spanning tree
class tree
{
	int a[20][20],l,u,w,i,j,v,e,visited[20]; // 'a' is the adjacency matrix, 'l' and 'u' store edge endpoints,
                                                 // 'w' is the edge weight, 'v' is the number of vertices,
                                                 // 'e' is the number of edges, and 'visited' tracks visited vertices
public:
	void input();   // Function to take graph input from the user
	void display(); // Function to display the adjacency matrix of the graph
	void minimum(); // Function to find and display the minimum spanning tree using Prim's algorithm
};

// Function to take graph input from the user
void tree::input()
{
	cout<<"Enter the no. of branches: "; // Prompts the user to enter the number of vertices (branches)
	cin>>v;                             // Reads the number of vertices

	for(i=0;i<v;i++) // Loop to initialize the visited array and adjacency matrix
	{
		visited[i]=0;       // Marks all vertices as not visited initially
		for(j=0;j<v;j++)
		{
			a[i][j]=999; // Initializes all entries in the adjacency matrix to a large value (representing infinity)
		}
	}

	cout<<"\nEnter the no. of connections: "; // Prompts the user to enter the number of edges (connections)
	cin>>e;                             // Reads the number of edges

	for(i=0;i<e;i++) // Loop to read edge details
	{
		cout<<"Enter the end branches of connections:  "<<endl; // Prompts for the endpoints of each edge
		cin>>l>>u;                                          // Reads the endpoints (vertices) of the edge
		cout<<"Enter the phone company charges for this connection:  "; // Prompts for the weight of the edge
		cin>>w;                                          // Reads the weight (cost) of the edge
		a[l-1][u-1]=a[u-1][l-1]=w;                 // Stores the weight in the adjacency matrix (undirected graph)
	}
}

// Function to display the adjacency matrix of the graph
void tree::display()
{
	cout<<"\nAdjacency matrix:";
	for(i=0;i<v;i++)
	{
		cout<<endl;
		for(j=0;j<v;j++)
		{
			cout<<a[i][j]<<"    "; // Prints each element of the adjacency matrix
		}
		cout<<endl;
	}
}

// Function to find and display the minimum spanning tree using Prim's algorithm
void tree::minimum()
{
	int p=0,q=0,total=0,min; // 'p' and 'q' store the endpoints of the minimum cost edge,
                                 // 'total' stores the total cost of the MST, and 'min' stores the minimum edge weight
	visited[0]=1;          // Marks the first vertex (0) as visited
	for(int count=0;count<(v-1);count++) // Loop to iterate 'v-1' times to find all edges of the MST
	{
		min=999;             // Initializes 'min' to a large value
		for(i=0;i<v;i++) // Loop to iterate through all vertices
		{
			if(visited[i]==1) // If the vertex 'i' is visited
			{
				for(j=0;j<v;j++) // Loop to iterate through all other vertices
				{
					if(visited[j]!=1) // If the vertex 'j' is not visited
					{
						if(min > a[i][j]) // If the weight of the edge (i, j) is less than the current minimum
						{
							min=a[i][j]; // Update 'min' with the new minimum weight
							p=i;       // Store the source vertex 'i'
							q=j;       // Store the destination vertex 'j'
						}
					}
				}
			}
		}
		visited[p]=1;       // Mark the destination vertex 'p' as visited
		visited[q]=1;       // Mark the destination vertex 'q' as visited
		total=total + min; // Add the minimum edge weight to the total cost
		cout<<"Minimum cost connection is "<<(p+1)<<" -> "<<(q+1)<<"  with charge : "<<min<< endl; // Print the minimum cost edge
	}
	cout<<"The minimum total cost of connections of all branches is: "<<total<<endl; // Print the total cost of the MST
}

// Main function - entry point of the program
int main()
{
	int ch;
	tree t; // Create an object 't' of the 'tree' class
	do
	{
		cout<<"==========PRIM'S ALGORITHM================="<<endl;
		cout<<"\n1.INPUT\n \n2.DISPLAY\n \n3.MINIMUM\n"<<endl; // Display the menu options
		cout<<"Enter your choice :"<<endl;
		cin>>ch; // Reads the user's choice

	switch(ch) // Switch statement to execute the selected option
	{
	case 1: cout<<"*******INPUT YOUR VALUES*******"<<endl;
		t.input();    // Call the 'input' function to get graph data
		break;

	case 2: cout<<"*******DISPLAY THE CONTENTS********"<<endl;
		t.display();  // Call the 'display' function to show the adjacency matrix
		break;

	case 3: cout<<"*********MINIMUM************"<<endl;
		t.minimum();  // Call the 'minimum' function to find and display the MST
		break;
	}

	}while(ch!=4); // Continue the loop until the user enters 4 to exit
	return 0;    // Returns 0 to indicate successful execution
}

