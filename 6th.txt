PS:There are flight paths between cities. If there is a flight between city A and city B then there is an edge between the cities. 
The cost of the edge can be the time that flight take to reach city B from A, or the amount of fuel used for the journey. 
Represent this as a graph. The node can be represented by airport name or name of the city. 
Use adjacency list representation of the graph or use adjacency matrix representation of the graph. 
Check whether the graph is connected or not. Justify the storage representation used.

#include<iostream>
#include<string.h>
using namespace std;

// Class to represent flight connections between cities
class flight
{ 	
public:
	int am[10][10];  // Adjacency matrix to store distances between cities.  am[i][j] stores the distance from city i to city j.
    char city_index[10][10];  // 2D character array to store city names.  city_index[i] stores the name of the ith city.
	flight();  // Constructor for the flight class.
	int create();  // Function to create the flight connections graph (get city names and distances).
	void display(int city_count); // Function to display the adjacency matrix representing the flight connections.
};

// Constructor for the flight class
flight::flight()  
{
	int i,j;
	for(i=0;i<10;i++)  // Loop to initialize the city_index array.
	{
		strcpy(city_index[i],"xx"); // Initializes each city name in the array to "xx".  This likely represents an empty or unassigned city.
	}
	for(i=0;i<10;i++) // Loop to initialize the adjacency matrix.
	{
		for(j=0;j<10;j++)
		{
			am[i][j]=0; // Initializes all distances in the adjacency matrix to 0.  This indicates no direct flight connection initially.
		}
	}
}

// Function to create the flight connections graph
int flight::create()
{
	int city_count=0,j,si,di,wt; // city_count: number of unique cities, si: source city index, di: destination city index, wt: distance/weight.
	char s[10],d[10],c; // s: source city name, d: destination city name, c: user input to continue adding flights.
	do
	{
		cout<<"\n\tEnter Source City: ";
		cin>>s; // Reads the source city name.
		cout<<"\n\tEnter Destination City : ";
		cin>>d; // Reads the destination city name.
		for(j=0;j<10;j++)
		{
			if(strcmp(city_index[j],s)==0)  // Checks if the source city 's' already exists in the city_index array.
			break;  // If found, exit the inner loop.
		}
		if(j==10) // If the source city 's' was not found in the city_index array (loop completed without break).
		{
			strcpy(city_index[city_count],s); // Add the source city 's' to the city_index array.
			city_count++; // Increment the city count.
		}

		for(j=0;j<10;j++)
		{
			if(strcmp(city_index[j],d)==0) // Checks if the destination city 'd' already exists in the city_index array.
			break;
		}

		if(j==10)  // If the destination city 'd' was not found in the city_index array.
		{
			strcpy(city_index[city_count],d); // Add the destination city 'd' to the city_index array.
			city_count++; // Increment the city count.
		}

		cout<<"\n\t Enter Distance From "<<s<<" And "<<d<<": ";
		cin>>wt; // Reads the distance between the source and destination cities.

		for(j=0;j<10;j++) // Loop to find the indices of the source and destination cities in the city_index array.
		{
			if(strcmp(city_index[j],s)==0)
				si=j; // Store the index of the source city.
			if(strcmp(city_index[j],d)==0)
				di=j; // Store the index of the destination city.
		}

		am[si][di]=wt; // Store the distance between the source and destination cities in the adjacency matrix.
		cout<<"\n\t Do you want to add more cities.....(y/n) : ";
		cin>>c;	// Ask the user if they want to add more flight connections.
	}while(c=='y'||c=='Y'); // Continue adding flights as long as the user enters 'y' or 'Y'.
  return(city_count); // Return the total number of unique cities.
}

// Function to display the adjacency matrix
void flight::display(int city_count)  
{
	int i,j;
	cout<<"\n\t Displaying Adjacency Matrix :\n\t";
	for(i=0;i<city_count;i++)
		cout<<"\t"<<city_index[i]; // Print the city names as column headers.
	cout<<"\n";

	for(i=0;i<city_count;i++)
	{
		cout<<"\t"<<city_index[i]; // Print the city names as row headers.
		for(j=0;j<city_count;j++)  
		{
			cout<<"\t"<<am[i][j];	// Print the distance between city i and city j from the adjacency matrix.
		}
		cout<<"\n";
	}
}

// Main function - entry point of the program
int main()
{
	flight f; // Create an object 'f' of the flight class.
	int n,city_count; // n: user's menu choice, city_count: number of cities.
	char c; // c: user input to continue in the main menu.
	do
	{
		cout<<"\n\t*** Flight Main Menu *****";
		cout<<"\n\t1. Create \n\t2. Adjacency Matrix\n\t3. Exit"; // Display the menu options.
		cout<<"\n\t.....Enter your choice : ";
		cin>>n; // Read the user's menu choice.
		switch(n) // Switch statement to handle user's choice.
		{
			case 1:
					city_count=f.create(); // Call the create function and store the number of cities.
					break;
			case 2:
					f.display(city_count); // Call the display function to show the adjacency matrix.
					break;
			case 3:
					return 0; // Exit the program.
		}
		cout<<"\n\t Do you Want to Continue in Main Menu....(y/n) : ";
		cin>>c; // Ask the user if they want to continue in the main menu.
	}while(c=='y'||c=='Y'); // Continue the loop as long as the user enters 'y' or 'Y'.
	return 0; // Return 0 to indicate successful program execution.
}

