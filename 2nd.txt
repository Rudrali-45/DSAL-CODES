PS:Implement all function of dictionary (ADT) using hashing and handle collision using chaining with/without replacement.  
Data : Set of (key,value) pairs, key are map to value, keys must be comparable, key must be unique. 
Standard operation : Insert (key,value), Find (key), Delete (key).

#include <iostream>
#include <string.h>
using namespace std;

class HashFunction {
private:
    typedef struct hash {
        long key;
        char name[10];
    } hash;
    hash h[10]; // An array of 10 hash structures to store key-value pairs.

public:
    HashFunction(); // Constructor for the HashFunction class.
    void insert();   // Function to insert a new key-value pair into the hash table.
    void display();  // Function to display the contents of the hash table.
    int find(long);  // Function to find the index of a given key in the hash table.
    void Delete(long); // Function to delete a key-value pair based on the key.
};

// Constructor implementation: Initializes the hash table.
HashFunction::HashFunction() {
    int i;
    for (i = 0; i < 10; i++) {
        h[i].key = -1;             // Initialize the key to -1, indicating an empty slot.
        strcpy(h[i].name, "NULL"); // Initialize the name to "NULL" for empty slots.
    }
}

// Delete function implementation: Deletes a key-value pair from the hash table.
void HashFunction::Delete(long k) {
    int index = find(k); // Call the find function to get the index of the key.
    if (index == -1) {
        cout << "\n\tKey Not Found"; // If find returns -1, the key is not in the table.
    } else {
        h[index].key = -1;             // Set the key at the found index to -1 (empty).
        strcpy(h[index].name, "NULL"); // Set the name at the found index to "NULL" (empty).
        cout << "\n\tKey is Deleted";    // Indicate that the key has been successfully deleted.
    }
}

// Find function implementation: Searches for a key in the hash table.
int HashFunction::find(long k) {
    int i;
    for (i = 0; i < 10; i++) {
        if (h[i].key == k) { // If the key at the current index matches the search key.
            cout << "\n\t" << h[i].key << " is Found at " << i << " Location With Name " << h[i].name;
            return i; // Return the index where the key is found.
        }
    }
    if (i == 10) {
        return -1; // If the loop completes without finding the key, return -1.
    }
    return -1; // Added this return statement to handle cases where the loop might not reach i == 10.
}

// Display function implementation: Prints the contents of the hash table.
void HashFunction::display() {
    int i;
    cout << "\n\t\tKey\t\tName";
    for (i = 0; i < 10; i++) {
        cout << "\n\th[" << i << "]\t" << h[i].key << "\t\t" << h[i].name;
    }
}

// Insert function implementation: Inserts a new key-value pair into the hash table using linear probing with a twist for handling collisions.
void HashFunction::insert() {
    char ans, n[10], ntemp[10];
    long k, temp;
    int v, hi, cnt = 0, flag = 0, i;
    do {
        if (cnt >= 10) {
            cout << "\n\tHash Table is FULL"; // If the table is full (10 entries), stop inserting.
            break;
        }

        cout << "\n\tEnter a Telephone No: ";
        cin >> k;
        cout << "\n\tEnter a Client Name: ";
        cin >> n;
        hi = k % 10; // Calculate the initial hash index using the modulo operator.

        if (h[hi].key == -1) {
            h[hi].key = k;          // If the slot is empty, insert the key.
            strcpy(h[hi].name, n); // Copy the name into the slot.
        } else {
            // Collision handling: If the slot is occupied.
            if (h[hi].key % 10 != hi) {
                // If the existing key's home position is not the current index (meaning it was also placed here due to collision).
                temp = h[hi].key;          // Store the existing key.
                strcpy(ntemp, h[hi].name); // Store the existing name.
                h[hi].key = k;             // Place the new key in the current slot.
                strcpy(h[hi].name, n);     // Place the new name in the current slot.

                // Linear probing to find an empty slot for the displaced key.
                for (i = hi + 1; i < 10; i++) {
                    if (h[i].key == -1) {
                        h[i].key = temp;
                        strcpy(h[i].name, ntemp);
                        flag = 1; // Set flag to indicate successful placement.
                        break;
                    }
                }
                // If no empty slot found after the initial hash index, wrap around to the beginning.
                for (i = 0; i < hi && flag == 0; i++) {
                    if (h[i].key == -1) {
                        h[i].key = temp;
                        strcpy(h[i].name, ntemp);
                        break;
                    }
                }
            } else {
                // If the existing key's home position is the current index (primary clustering).
                // Perform linear probing to find the next empty slot.
                for (i = hi + 1; i < 10; i++) {
                    if (h[i].key == -1) {
                        h[i].key = k;
                        strcpy(h[i].name, n);
                        flag = 1;
                        break;
                    }
                }
                // If no empty slot found after the initial hash index, wrap around to the beginning.
                for (i = 0; i < hi && flag == 0; i++) {
                    if (h[i].key == -1) {
                        h[i].key = k;
                        strcpy(h[i].name, n);
                        break;
                    }
                }
            }
        }
        flag = 0;   // Reset the flag for the next insertion.
        cnt++;      // Increment the count of inserted elements.
        cout << "\n\t..... Do You Want to Insert More Key: y/n";
        cin >> ans;
    } while (ans == 'y' || ans == 'Y');
}

int main() {
    long k;
    int ch, index;
    char ans;
    HashFunction obj; // Create an object of the HashFunction class.

    do {
        cout << "\n\t*** Telephone (ADT) *****";
        cout << "\n\t1. Insert\n\t2. Display\n\t3. Find\n\t4. Delete\n\t5. Exit";
        cout << "\n\t..... Enter Your Choice: ";
        cin >> ch;
        switch (ch) {
        case 1:
            obj.insert(); // Call the insert function.
            break;
        case 2:
            obj.display(); // Call the display function.
            break;
        case 3:
            cout << "\n\tEnter a Key Which You Want to Search: ";
            cin >> k;
            index = obj.find(k); // Call the find function and store the result.
            if (index == -1) {
                cout << "\n\tKey Not Found"; // If find returns -1, the key was not found.
            }
            break;
        case 4:
            cout << "\n\tEnter a Key Which You Want to Delete: ";
            cin >> k;
            obj.Delete(k); // Call the Delete function.
            break;
        case 5:
            break; // Exit the switch statement.
        }
        cout << "\n\t..... Do You Want to Continue in Main Menu:y/n ";
        cin >> ans;
    } while (ans == 'y' || ans == 'Y'); // Continue the loop as long as the user enters 'y' or 'Y'.

    return 0; // Indicate successful program execution.
}
              

